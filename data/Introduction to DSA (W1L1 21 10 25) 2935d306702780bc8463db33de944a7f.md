# Introduction to DSA (W1L1 21/10/25)

- **Data** is a sequence of symbols that can be translated into information through interpretation
    - Metadata is what we use as context to interpret that data into information
    - E.g. Hexadecimals to integers
    - ASCII to alphabets

| **Word** | **Meaning** | **Example** |
| --- | --- | --- |
| **Data** | A certain sequence of symbols that is open for interpretation. | ▪️▪️▪️ ▬▬ ▪️▪️▪️ (Morse code for “SOS”) |
| **Information** | Data that has been interpreted in the context of metadata. | “Our ship is in distress, please help.” |
| **Knowledge** | Theoretical or practical understanding of a subject. | “The captain and crew will be able to navigate our ship through these stormy weathers.” |
| **Wisdom** | The ability to think and act using knowledge, experience, understanding, common sense and insight. | “As the captain of the ship I have decided we will delay our journey for a day, due to the bad weather forecasts.” |
- **Data structure** is a collection of data values, the relationships between these data values and the functions that can be applied to these data values
    - needs to support *efficiency* (in terms of storage and access) and *flexibility* (can add/delete/search)
    - can be divided into two different categories: **array structures** and **linked structures**
        - **array** is a data structure that stores data in a continuous block of memory and usually stores homogenous data
            
            Pros: 
            
            - Allow random access
            - easy to copy
            - takes less memory
            
            Cons:
            
            - fixed sizes
            - difficult to expand with new data
        - **linked data structure** breaks data down into *nodes*(units of storage that store data and a reference to a memory address from another node) and typically stores heterogenous data
            
            Pros:
            
            - more flexible to add new items dynamically
            - easily expandable
            
            Cons:
            
            - access to data is not as fast as in an array
- **Algorithms** are a series of steps to solve a problem

| Algorithm | Description | Properties |
| --- | --- | --- |
| Brute force  | tries all candidates of a solution one by one to see if any of them satisfies the solution | simple but inefficient especially for large datasets |
| Divide and conquer | Break a big problem down into smaller problems that are easier to solve | more efficient, relies on recursion |
| Backtracking  | Tries incrementally a subset of candidates of a solution and then backtracks if candidates do not satisfy the solution | only useful in certain problem domains(e.g. solving a maze), more efficient than brute force but relies on recursion and tree search |
- **Data Encapsulation** is where you wrap up data in a shell of access functions(e.g. self.__data hidden behind .get(), .peek(), .set()) thus the data would be considered private
- **Abstract Data Type(ADT)** defines a data structure in terms of what functions can be performed on it but does not reveal how these functions are implemented internally
    - i.e. the mathematical description of the functionality of a data structure, where the data structure itself is more concrete and includes the actual implementation of the ADT

- **Stacks** are a linear data structure where we can only work on the top (LIFO)
    - defined only by 3 functions: push, pop, get
    - ADT of a stack can be implemented through either a linked list or an array
    
- **Big-O Notation**
    - expression of the number of steps/calculations made by an algorithm in terms of the input size *n*
    - only takes the highest order, e.g. T(n) = 5n^3 + 2n^2 + 3 = O(n^3)

| **Big-O Notation** | **Algorithm** | **Example** |
| --- | --- | --- |
| **O(1)** | Constant time | `x = my_list[0]` → Accessing a single element takes the same time regardless of list size |
| **O(log n)** | Logarithmic time | `import bisect`<br>`bisect.bisect(my_sorted_list, 10)` → Binary search halves the search space each step |
| **O(n)** | Linear time | `for i in my_list:`<br>    `print(i)` → Iterating once through a list |
| **O(n log n)** | Log-linear time | `sorted_list = sorted(my_list)` → Merge sort or quicksort average case |
| **O(n²)** | Quadratic time | `for i in my_list:`<br>    `for j in my_list:`<br>        `print(i, j)` → Nested loops over same list |
| **O(2ⁿ)** | Exponential time | `def fib(n):`<br>    `if n <= 1:`<br>        `return n`<br>    `return fib(n-1) + fib(n-2)` → Naive recursive Fibonacci |
| **O(n!)** | Factorial time | `import itertools`<br>`for perm in itertools.permutations(my_list):`<br>    `print(perm)` → Generating all permutations (e.g., brute-force TSP) |